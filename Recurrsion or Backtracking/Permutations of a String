ðŸ”¹ Problem Restatement
We need to generate all unique permutations of a given string s.
 -> The string may contain duplicate characters.
 -> We must return each permutation only once.

ðŸ”¹ Examples
Example 1
Input: s = "ABC"
Output:
["ABC", "ACB", "BAC", "BCA", "CAB", "CBA"]
ðŸ‘‰ There are 3! = 6 unique permutations.

Example 2
Input: s = "ABSG"
Output: 24 unique permutations (since 4! = 24).

Example 3
Input: s = "AAA"
Output: ["AAA"]
ðŸ‘‰ All characters same â†’ only 1 unique permutation.


ðŸ”¹ Approaches
1. Brute Force Approach
ðŸ‘‰ Generate all permutations (including duplicates) and then use a set to remove duplicates.

# Algorithm
1. Generate permutations using recursion/backtracking.
2. Store them in a set to automatically remove duplicates.
3. Convert the set to a vector/array and return.

C++ Code (Brute Force)

#include <bits/stdc++.h>
using namespace std;

void permute(string s, int l, int r, set<string>& result) {
    if (l == r) {
        result.insert(s); // add to set to avoid duplicates
        return;
    }
    for (int i = l; i <= r; i++) {
        swap(s[l], s[i]);
        permute(s, l + 1, r, result);
        swap(s[l], s[i]); // backtrack
    }
}

vector<string> getPermutations(string s) {
    set<string> result;
    permute(s, 0, s.size() - 1, result);
    return vector<string>(result.begin(), result.end());
}

int main() {
    string s = "AAB";
    vector<string> ans = getPermutations(s);
    for (auto &p : ans) cout << p << " ";
    return 0;
}


â± Time Complexity: O(n! Ã— n log n) (because of set insertions)
ðŸ“¦ Space Complexity: O(n!)

----

2. Optimized Approach (Backtracking with Pruning)
ðŸ‘‰ Instead of generating duplicates, avoid them during recursion.

Idea
1. Sort the string first.
2. While swapping, skip characters that are already used at the same recursion depth.


#include <bits/stdc++.h>
using namespace std;

void backtrack(string &s, vector<bool> &used, string &current, vector<string> &result) {
    if (current.size() == s.size()) {
        result.push_back(current);
        return;
    }
    for (int i = 0; i < s.size(); i++) {
        if (used[i]) continue;
        // skip duplicates
        if (i > 0 && s[i] == s[i - 1] && !used[i - 1]) continue;
        
        used[i] = true;
        current.push_back(s[i]);
        backtrack(s, used, current, result);
        current.pop_back();
        used[i] = false;
    }
}

vector<string> getPermutations(string s) {
    sort(s.begin(), s.end()); // sort to handle duplicates
    vector<string> result;
    vector<bool> used(s.size(), false);
    string current = "";
    backtrack(s, used, current, result);
    return result;
}

int main() {
    string s = "AAB";
    vector<string> ans = getPermutations(s);
    for (auto &p : ans) cout << p << " ";
    return 0;
}


â± Time Complexity: O(n! Ã— n) (generate only unique ones)
ðŸ“¦ Space Complexity: O(n) (recursion + used array)

----

ðŸ”¹ Comparison
Approach	Duplicates Removed:	{Time Complexity,	Space Complexity,	Notes}
Brute Force	After generation:	{O(n! Ã— n log n),	O(n!), 	Simple, but wastes time generating duplicates}
Optimized	During recursion: 	{O(n! Ã— n),	O(n),	Efficient, avoids duplicates early}

