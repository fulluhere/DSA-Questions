## N-Queen Problem

🔹 Problem Restatement
 We need to place n queens on an n × n chessboard so that:
  -> No two queens are in the same row.
  -> No two queens are in the same column.
  -> No two queens are on the same diagonal.

We return all distinct solutions in the form of permutations:
👉 The i-th element in the permutation means the row position of the queen in the i-th column.

🔹 Examples
Example 1

Input: n = 1
Output: [ [1] ]
✅ One queen in one cell.

Example 2

Input: n = 4
Output:[ [2, 4, 1, 3], 
  [3, 1, 4, 2] ]
✅ Two valid placements exist.

Example 3

Input: n = 2
Output: []
✅ No possible arrangement.

🔹 Approaches
1️⃣ Brute Force Approach

👉 Generate all possible permutations of [1, 2, …, n] (each representing queen placements in different rows for each column).
👉 Check if each permutation is valid (no diagonal conflicts).

C++ Code (Brute Force)

#include <bits/stdc++.h>
using namespace std;

bool isValid(vector<int>& board) {
    int n = board.size();
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (abs(board[i] - board[j]) == abs(i - j)) return false; // diagonal check
        }
    }
    return true;
}

vector<vector<int>> solveNQueensBrute(int n) {
    vector<int> board(n);
    iota(board.begin(), board.end(), 1); // fill [1..n]
    vector<vector<int>> result;

    do {
        if (isValid(board)) result.push_back(board);
    } while (next_permutation(board.begin(), board.end()));

    return result;
}

int main() {
    int n = 4;
    auto solutions = solveNQueensBrute(n);
    for (auto &sol : solutions) {
        for (int x : sol) cout << x << " ";
        cout << "\n";
    }
}


⏱ Time Complexity: O(n! × n) (checking diagonals for each permutation)
📦 Space Complexity: O(n)

----

2️⃣ Optimized Backtracking Approach

👉 Place queens column by column.
👉 Use sets/arrays to track used rows and diagonals.
👉 If placement is valid, recurse further; else, backtrack.

C++ Code (Optimized)

#include <bits/stdc++.h>
using namespace std;

void solve(int col, int n, vector<int>& board, 
           vector<bool>& rows, vector<bool>& diag1, vector<bool>& diag2, 
           vector<vector<int>>& result) {
    if (col == n) {
        result.push_back(board);
        return;
    }

    for (int row = 1; row <= n; row++) {
        if (!rows[row] && !diag1[col - row + n] && !diag2[col + row]) {
            board[col] = row;
            rows[row] = diag1[col - row + n] = diag2[col + row] = true;

            solve(col + 1, n, board, rows, diag1, diag2, result);

            rows[row] = diag1[col - row + n] = diag2[col + row] = false;
        }
    }
}

vector<vector<int>> solveNQueens(int n) {
    vector<vector<int>> result;
    vector<int> board(n);
    vector<bool> rows(n + 1, false), diag1(2 * n, false), diag2(2 * n, false);
    solve(0, n, board, rows, diag1, diag2, result);
    return result;
}

int main() {
    int n = 4;
    auto solutions = solveNQueens(n);
    for (auto &sol : solutions) {
        for (int x : sol) cout << x << " ";
        cout << "\n";
    }
}


⏱ Time Complexity: ~O(n!) but with heavy pruning (much faster in practice).
📦 Space Complexity: O(n) for recursion + O(3n) for helper arrays.

----

🔹 Comparison
Approach	Idea: {Time Complexity,	Space Complexity,	Notes}
Brute Force	Generate all permutations: {O(n! × n)	, O(n),	Simple but slow for n > 8}
Backtracking	Place queens col by col:	{O(n!) (pruned)	, O(n)	Efficient, works up to n=10 quickly}

✅ Best Approach → Backtracking with pruning is the expected solution
