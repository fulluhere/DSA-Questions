# Count Pairs with Given Sum

## üìå Problem Statement
You are given an array `arr[]` and an integer `target`.  
You need to count all pairs in the array such that their **sum equals the given target**.

---

## ‚ú® Examples

### Example 1:
Input:  arr = [1, 5, 7, -1, 5], target = 6
Output:  3
Explanation: Pairs with sum 6 are (1, 5), (7, -1), and (1, 5).
---

## ‚úÖ Constraints
- `1 ‚â§ arr.size() ‚â§ 10^5`
- `-10^4 ‚â§ arr[i] ‚â§ 10^4`
- `0 ‚â§ target ‚â§ 10^4`

---

## ‚è±Ô∏è Expected Complexity
- Time Complexity: **O(n)**
- Auxiliary Space: **O(n)**

---

## ‚úÖ Constraints
- `1 ‚â§ arr.size() ‚â§ 10^5`
- `-10^4 ‚â§ arr[i] ‚â§ 10^4`
- `0 ‚â§ target ‚â§ 10^4`

---

## c++ Solution 
## üîé Approaches

### 1Ô∏è‚É£ Brute Force (O(n¬≤), O(1))
- Check every possible pair `(i, j)` with nested loops.
- Increment count when `arr[i] + arr[j] == target`.

---

### 2Ô∏è‚É£ Sorting + Two Pointers (O(n log n), O(1))
- Sort the array.
- Use two pointers `left` and `right`.  
- If `arr[left] + arr[right] == target`, move both pointers inward.  
- If sum < target, move `left++`.  
- If sum > target, move `right--`.  
- Careful with duplicates ‚Üí count them properly.

---

### 3Ô∏è‚É£ Optimized Hashing (O(n), O(n))
- Use a hash map to store frequencies.  
- For each element `x`, check if `target - x` exists.  
- Add its frequency to the count.  
- Update frequency of `x`.

---

## üñ•Ô∏è C++ Implementation
```cpp
#include <bits/stdc++.h>
using namespace std;

// 1Ô∏è‚É£ Brute Force O(n^2)
int countPairsBrute(vector<int>& arr, int target) {
    int n = arr.size();
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (arr[i] + arr[j] == target) {
                count++;
            }
        }
    }
    return count;
}

// 2Ô∏è‚É£ Sorting + Two Pointers O(n log n)
int countPairsTwoPointers(vector<int>& arr, int target) {
    sort(arr.begin(), arr.end());
    int left = 0, right = arr.size() - 1, count = 0;

    while (left < right) {
        int sum = arr[left] + arr[right];

        if (sum == target) {
            // Handle duplicates
            if (arr[left] == arr[right]) {
                int num = right - left + 1;
                count += (num * (num - 1)) / 2;
                break;
            } else {
                int leftCount = 1, rightCount = 1;

                while (left + 1 < right && arr[left] == arr[left + 1]) {
                    leftCount++;
                    left++;
                }
                while (right - 1 > left && arr[right] == arr[right - 1]) {
                    rightCount++;
                    right--;
                }
                count += leftCount * rightCount;
                left++;
                right--;
            }
        } else if (sum < target) {
            left++;
        } else {
            right--;
        }
    }
    return count;
}

// 3Ô∏è‚É£ Optimized Hashing O(n)
int countPairsHashing(vector<int>& arr, int target) {
    unordered_map<int, int> freq;
    int count = 0;

    for (int x : arr) {
        int complement = target - x;

        if (freq.find(complement) != freq.end()) {
            count += freq[complement];
        }

        freq[x]++;
    }
    return count;
}

int main() {
    vector<int> arr = {1, 5, 7, -1, 5};
    int target = 6;

    cout << "Array: ";
    for (int x : arr) cout << x << " ";
    cout << "\nTarget: " << target << "\n\n";

    cout << "Brute Force Count = " << countPairsBrute(arr, target) << endl;
    cout << "Two Pointers Count = " << countPairsTwoPointers(arr, target) << endl;
    cout << "Hashing Count = " << countPairsHashing(arr, target) << endl;

    return 0;
}


------

## Comparison
Approach:	{Time Complexity	,Space Complexity}
Brute Force:	{O(n¬≤),	O(1)}
Sorting + Two Pointers:	{O(n log n),	O(1)}	
Optimized Hashing:	{O(n),	O(n)}

