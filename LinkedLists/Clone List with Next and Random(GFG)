# Problem: Clone List with Next and Random Pointer

You are given a special linked list with **n nodes**, where each node has:  
- A `next` pointer (points to the next node in the list).  
- A `random` pointer (points to any random node in the list or `NULL`).  

The task is to **construct a deep copy of this linked list**.  
- The copy should have the same number of nodes.  
- Each new node should have the same value as the original.  
- Both `next` and `random` pointers of the new list should point to **new nodes only**, not the original ones.  
- The **original linked list should remain unchanged**.  

Each node is represented as `[val, random_index]` where:  
- `val` → value of the node.  
- `random_index` (1-based index) → the index of the node that the `random` pointer points to (or `NULL`).  

---

### Example 1
**Input:**  
`head = [[1, 3], [3, 3], [5, NULL], [9, 3]]`  

**Output:**  
`[[1, 3], [3, 3], [5, NULL], [9, 3]]`  

**Explanation:**  
- Node 1 → Next: Node 3, Random: Node 5  
- Node 3 → Next: Node 5, Random: Node 5  
- Node 5 → Next: Node 9, Random: NULL  
- Node 9 → Next: NULL, Random: Node 5 

## Brute Force Approach (Using HashMap)

**Idea:**  
- Create a mapping from each original node to its new cloned node.  
- First pass: clone all nodes and store in map.  
- Second pass: assign `next` and `random` using the map.  

```cpp
#include <unordered_map>
using namespace std;

struct Node {
    int val;
    Node* next;
    Node* random;
    Node(int x) : val(x), next(nullptr), random(nullptr) {}
};

Node* cloneListBrute(Node* head) {
    if (!head) return nullptr;

    unordered_map<Node*, Node*> mp;
    Node* curr = head;

    // First pass: clone nodes
    while (curr) {
        mp[curr] = new Node(curr->val);
        curr = curr->next;
    }

    // Second pass: assign next & random
    curr = head;
    while (curr) {
        mp[curr]->next = mp[curr->next];
        mp[curr]->random = mp[curr->random];
        curr = curr->next;
    }

    return mp[head];
}

## Optimized Approach (O(1) Extra Space)
Idea: 1-Insert cloned nodes in between original nodes.
2-Assign random pointers to cloned nodes.
3-Separate original and cloned lists.

Node* cloneListOptimized(Node* head) {
    if (!head) return nullptr;

    Node* curr = head;

    // Step 1: Insert cloned nodes
    while (curr) {
        Node* next = curr->next;
        curr->next = new Node(curr->val);
        curr->next->next = next;
        curr = next;
    }

    // Step 2: Set random pointers
    curr = head;
    while (curr) {
        if (curr->random)
            curr->next->random = curr->random->next;
        curr = curr->next->next;
    }

    // Step 3: Separate cloned list
    curr = head;
    Node* dummy = new Node(0);
    Node* copy = dummy;

    while (curr) {
        Node* next = curr->next->next;

        copy->next = curr->next;
        copy = copy->next;

        curr->next = next;
        curr = next;
    }

    return dummy->next;
}

## Comparison
Approach:	{Time Complexity,	Space Complexity,	Notes}
Brute Force (HashMap):	{O(n),	O(n),	Easy to implement but extra space}
Optimized Approach: {O(n),	O(1),	Best approach, no extra space used}

