üßë‚Äçüíª Problem: Clone an Undirected Graph
This is a classic graph traversal and copying problem that requires careful handling of node 
relationships to avoid infinite loops and correctly replicate the graph structure.

The Goal
The core task is to implement a cloneGraph() function that takes a node from the original graph
and returns a corresponding node in a newly created, identical graph. The new graph must be a
deep copy, meaning we create entirely new nodes and new connections, leaving the original graph
untouched.

Create a clone of the graph, where each node in the graph contains an integer val and an array
(neighbors) of nodes, containing nodes that are adjacent to the current node.

class Node {
    val: integer
    neighbors: List[Node]
}

Examples :

Input: n = 4, adjList[][] = [[1, 2], [0, 2], [0, 1, 3], [2]]
Output: true
Explanation: 
As the cloned graph is identical to the original one the driver code will print true.
----
  
// class Node {
// public:
//     int val;
//     vector<Node*> neighbors;
//     Node() {
//         val = 0;
//         neighbors = vector<Node*>();
//     }
//     Node(int _val) {
//         val = _val;
//         neighbors = vector<Node*>();
//     }
//     Node(int _val, vector<Node*> _neighbors) {
//         val = _val;
//         neighbors = _neighbors;
//     }
// };

1. Brute Force Approach

Idea: Create new nodes for every original node, but don‚Äôt worry about connecting neighbors
immediately.

Do a two-pass traversal:
 1- create all nodes and store them in a map.
 2- iterate again to connect neighbors.

class Solution {
public:
    unordered_map<Node*, Node*> mp;

    Node* cloneGraph(Node* node) {
        if (!node) return nullptr;

        // Step 1: Create all nodes
        createNodes(node);

        // Step 2: Connect neighbors
        connectEdges(node);

        return mp[node];
    }

    void createNodes(Node* node) {
        if (mp.find(node) != mp.end()) return;

        Node* copy = new Node(node->val);
        mp[node] = copy;

        for (auto neigh : node->neighbors) {
            createNodes(neigh);
        }
    }

    void connectEdges(Node* node) {
        if (!node || mp[node]->neighbors.size() > 0) return;

        for (auto neigh : node->neighbors) {
            mp[node]->neighbors.push_back(mp[neigh]);
            connectEdges(neigh);
        }
    }
};


----

üîπ 3. Optimized Approach (DFS)

Here, while cloning each node, we also directly clone its neighbors recursively ‚Üí single 
pass.

class Solution {
public:
    unordered_map<Node*, Node*> mp;

    Node* cloneGraph(Node* node) {
        if (!node) return nullptr;

        if (mp.find(node) != mp.end()) return mp[node];

        Node* copy = new Node(node->val);
        mp[node] = copy;

        for (auto neigh : node->neighbors) {
            copy->neighbors.push_back(cloneGraph(neigh));
        }

        return copy;
    }
};


----
  
üîπ 4. Optimized Approach (BFS)
We can also do BFS to avoid recursion:


class Solution {
public:
    Node* cloneGraph(Node* node) {
        if (!node) return nullptr;

        unordered_map<Node*, Node*> mp;
        queue<Node*> q;

        // Create first node
        Node* copy = new Node(node->val);
        mp[node] = copy;
        q.push(node);

        while (!q.empty()) {
            Node* curr = q.front();
            q.pop();

            for (auto neigh : curr->neighbors) {
                if (mp.find(neigh) == mp.end()) {
                    mp[neigh] = new Node(neigh->val);
                    q.push(neigh);
                }
                mp[curr]->neighbors.push_back(mp[neigh]);
            }
        }
        return copy;
    }
};

----

‚è±Ô∏è Time & Space Complexity Comparison
Approach:	{Time Complexity, Space Complexity}
Brute Force (Two-Pass):	{O(N + M), O(N)}	
DFS (Optimized):	{O(N + M), O(N)}
BFS (Optimized):	{O(N + M), O(N)}

