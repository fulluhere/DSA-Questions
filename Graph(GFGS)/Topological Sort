üîù Topological Sort (DAG)
Problem in Brief
We are given a Directed Acyclic Graph (DAG) with V vertices and E edges.
We need to find a linear ordering of vertices such that for every directed edge u ‚Üí v, vertex u appears before v in the order.

Example-

Input: V = 4, E = 3, edges[][] = [[3, 0], [1, 0], [2, 0]]
Output: true
Explanation: The output true denotes that the order is valid. Few valid Topological orders for the given graph are:
[3, 2, 1, 0]
[1, 2, 3, 0]
[2, 3, 1, 0]

----

1Ô∏è‚É£ Brute Force (Naive Check Ordering)
Try all permutations of vertices and check if they satisfy the topological condition.
Generate all V! permutations.
For each ordering, verify if every edge u ‚Üí v satisfies pos[u] < pos[v].
First valid ordering is the answer.


bool isValid(vector<int>& order, vector<vector<int>>& edges, int V) {
    vector<int> pos(V);
    for (int i = 0; i < V; i++) pos[order[i]] = i;
    for (auto e : edges) {
        if (pos[e[0]] > pos[e[1]]) return false;
    }
    return true;
}

---- 

2Ô∏è‚É£ DFS-Based Topological Sort (Recursive)
Do DFS for each node.
Push node into stack after exploring all neighbors.
Pop stack to get ordering.

void dfs(int node, vector<int> adj[], vector<int>& vis, stack<int>& st) {
    vis[node] = 1;
    for (int neigh : adj[node]) {
        if (!vis[neigh]) dfs(neigh, adj, vis, st);
    }
    st.push(node);
}

vector<int> topoSortDFS(int V, vector<vector<int>>& edges) {
    vector<int> adj[V];
    for (auto e : edges) adj[e[0]].push_back(e[1]);

    vector<int> vis(V, 0);
    stack<int> st;

    for (int i = 0; i < V; i++)
        if (!vis[i]) dfs(i, adj, vis, st);

    vector<int> topo;
    while (!st.empty()) {
        topo.push_back(st.top());
        st.pop();
    }
    return topo;
}
----

3Ô∏è‚É£ BFS-Based Topological Sort **(Kahn‚Äôs Algorithm ‚Äì Optimized)**
Compute in-degree for all nodes.
Start with nodes having in-degree 0.
Process and reduce in-degrees of neighbors.
Push new 0 in-degree nodes into queue.

vector<int> topoSortBFS(int V, vector<vector<int>>& edges) {
    vector<int> adj[V];
    for (auto e : edges) adj[e[0]].push_back(e[1]);

    vector<int> indeg(V, 0);
    for (int i = 0; i < V; i++) {
        for (int neigh : adj[i]) indeg[neigh]++;
    }

    queue<int> q;
    for (int i = 0; i < V; i++) if (indeg[i] == 0) q.push(i);

    vector<int> topo;
    while (!q.empty()) {
        int node = q.front(); q.pop();
        topo.push_back(node);

        for (int neigh : adj[node]) {
            indeg[neigh]--;
            if (indeg[neigh] == 0) q.push(neigh);
        }
    }
    return topo;
}


----

## Comparison

Approach:	{Time Complexity,	Space Complexity}
Brute Force (Permutation):	{O(V! * E), O(V)}
DFS (Stack Method):	{O(V + E),	O(V + E)}
BFS (Kahn‚Äôs Algo):	{O(V + E),	O(V)}

